{"version":3,"file":"C:\\Users\\PRAKASHSELVARAJ\\Blockchain\\Home Depot\\Development\\chaincode_0901\\src\\repositories\\crud.repository.ts","sources":["C:\\Users\\PRAKASHSELVARAJ\\Blockchain\\Home Depot\\Development\\chaincode_0901\\src\\repositories\\crud.repository.ts"],"names":[],"mappings":"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","sourcesContent":["\r\n\r\nimport { Context } from \"fabric-contract-api\";\r\nimport { Iterators } from \"fabric-shim\";\r\n\r\nconst Logger = require('../logger');\r\nconst logger = Logger.getLogger('./repositories/crud.repository.ts');\r\n\r\n\r\nexport class DocumentIndex {\r\n    public Items : string[] = [];\r\n    public DelayIndexUpdate : boolean = false;\r\n    public NeedsToBePersisted : boolean = false;\r\n    constructor(init?:Partial<DocumentIndex>) {\r\n        global.Object.assign(this, init);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport abstract class CRUDRepository<T> {\r\n\r\n    protected objectType: string = Object.getPrototypeOf(this).objectType;\r\n    protected requirePDC: boolean = Object.getPrototypeOf(this).requirePDC;\r\n    protected pdcResolver?: (ctx:Context)=>Promise<string> = Object.getPrototypeOf(this).pdcResolver;\r\n    protected defaultRecordID: string = 'DEFAULT';\r\n    \r\n    private TCreator : { new (init?:Partial<T>) : T };\r\n    protected TContext : Context;\r\n\r\n    private Index : DocumentIndex | undefined;\r\n    private DelayIndexUpdate : boolean = false;\r\n\r\n    constructor(tcreator : { new (init?:Partial<T>) : T }, ctx : Context, delayIndexUpdate : boolean = false) { \r\n        this.TCreator = tcreator;\r\n        this.TContext = ctx;\r\n        this.DelayIndexUpdate = delayIndexUpdate;\r\n    }\r\n\r\n\r\n\r\n\r\n    public abstract getStorageKeyForModel(currentModel : T) : string;\r\n\r\n\r\n\r\n\r\n\r\n    public getStorageKey(recordID : string = this.defaultRecordID) : string {\r\n        return this.TContext.stub.createCompositeKey(this['objectType'], [recordID]);\r\n    }\r\n\r\n    public async exists(recordID: string = this.defaultRecordID) : Promise<boolean> {\r\n        return await this.existsWithStorageKey(this.getStorageKey(recordID));\r\n    }\r\n    public async existsWithStorageKey(storageKey : string) : Promise<boolean> {        \r\n        try {\r\n            const currentRecord : T = await this.getWithStorageKey(storageKey);\r\n            if (currentRecord === undefined) {\r\n                logger.debug(`---CRUD-REPO : existsWithStorageKey => failed locating record`);\r\n                return false;\r\n            } else {\r\n                logger.debug(`---CRUD-REPO : existsWithStorageKey => success locating record`);\r\n                return true;\r\n            }\r\n        } catch (err) {                \r\n            logger.debug(`---CRUD-REPO : existsWithStorageKey => error locating record`);                  \r\n            logger.debug(`---CRUD-REPO : existsWithStorageKey => ERROR: ${JSON.stringify(err)}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public async create(modelToCreate: T) : Promise<T> {\r\n        // Get the storage key for the Model\r\n        const storageKey : string = this.getStorageKeyForModel(modelToCreate);\r\n\r\n        // Make sure the Model does not exist in the blockchain\r\n        const exists = await this.existsWithStorageKey(storageKey);\r\n        if (exists) {\r\n            throw new Error(`ERROR: create function in CRUDBaseContract failed.  A record already exists in the blockchain with storage key ${storageKey}`);\r\n        }\r\n\r\n        return await this.saveWithStorageKey(modelToCreate, storageKey);\r\n    }\r\n\r\n    public async update(modelToUpdate: T) : Promise<T> {\r\n        // Get the storage key for the Model\r\n        const storageKey : string = this.getStorageKeyForModel(modelToUpdate);\r\n\r\n        // Make sure the Model exists in the blockchain\r\n        const exists = await this.existsWithStorageKey(storageKey);\r\n        if (!exists) {\r\n            throw new Error(`ERROR: update function in CRUDBaseContract failed.  No records exist in the blockchain with storage key ${storageKey}`);\r\n        }\r\n\r\n        return await this.saveWithStorageKey(modelToUpdate, storageKey);\r\n    }\r\n\r\n    public async save(modelToCreateOrUpdate: T) : Promise<T> {\r\n        const storageKey : string = this.getStorageKeyForModel(modelToCreateOrUpdate);\r\n        return await this.saveWithStorageKey(modelToCreateOrUpdate, storageKey);\r\n    }\r\n    public async saveWithStorageKey(modelToCreateOrUpdate: T, storageKey : string) : Promise<T> {\r\n        // Serialize and store the provided Model\r\n        const buffer = Buffer.from(JSON.stringify(modelToCreateOrUpdate));\r\n        if (this.requirePDC) {\r\n            // Get the PDC name\r\n            const pdcName : string = await this.pdcResolver(this.TContext);\r\n\r\n            // Store the data in the PDC with the matching storageKey\r\n            await this.TContext.stub.putPrivateData(pdcName, storageKey, buffer);\r\n        } else {\r\n            await this.TContext.stub.putState(storageKey, buffer);\r\n        }\r\n\r\n        // Return the stored Model\r\n        return modelToCreateOrUpdate;\r\n    }\r\n\r\n    \r\n    public async get(recordID: string = this.defaultRecordID) : Promise<T | undefined> {\r\n        // Create the storage key\r\n        logger.debug(`---CRUD-REPO : get => retrieving record: ${recordID}`);\r\n        const storageKey : string = this.getStorageKey(recordID); \r\n        logger.debug(`---CRUD-REPO : get => storage key: ${storageKey}`);\r\n\r\n        // Retrieve the Model from storage using the storage key\r\n        try {\r\n            const currentRecord : T = await this.getWithStorageKey(storageKey);\r\n            logger.debug(`---CRUD-REPO : get => success retrieving record`);\r\n            return currentRecord;\r\n        } catch (err) {                \r\n            logger.debug(`---CRUD-REPO : get => error retrieving record`);                  \r\n            logger.debug(`---CRUD-REPO : get => ERROR: ${JSON.stringify(err)}`);\r\n        }\r\n    }\r\n    public async getWithStorageKey(storageKey : string) : Promise<T | undefined> {    \r\n        // Get a list of all record IDs in the index        \r\n        logger.debug(`---CRUD-REPO : getWithStorageKey => retrieving a record with storage key: ${storageKey}`); \r\n    \r\n        // Attempt to retrieve the Model from the blockchain \r\n        let buffer : Buffer; \r\n        logger.debug(`---CRUD-REPO : getWithStorageKey => record stored in PDC: ${this.requirePDC}`);\r\n        if (this.requirePDC) {\r\n            // Get the PDC name\r\n            const pdcName : string = await this.pdcResolver(this.TContext);\r\n            logger.debug(`---CRUD-REPO : getWithStorageKey => PDC Name: ${pdcName}`);\r\n\r\n            // Get the data in the PDC with the matching storageKey\r\n            try {\r\n                buffer = await this.TContext.stub.getPrivateData(pdcName, storageKey);\r\n            } catch (err) {                \r\n                logger.debug(`---CRUD-REPO : getWithStorageKey => Failed to retrieve the record from the PDC`);                   \r\n                logger.debug(`---CRUD-REPO : getWithStorageKey => ERROR: ${JSON.stringify(err)}`);\r\n            }\r\n        } else {\r\n            try {\r\n                buffer = await this.TContext.stub.getState(storageKey);\r\n            } catch (err) {                \r\n                logger.debug(`---CRUD-REPO : getWithStorageKey => Failed to retrieve the record from the WorldState`);                   \r\n                logger.debug(`---CRUD-REPO : getWithStorageKey => ERROR: ${JSON.stringify(err)}`);\r\n            }\r\n        }\r\n\r\n        // If we did find something, then convert the value from the blockchain into a Model, otherwise return undefined\r\n        if (!!buffer && buffer.length > 0) {\r\n            logger.debug(`---CRUD-REPO : getWithStorageKey => Retrieved the record buffer: ${buffer.toString()}`);    \r\n            \r\n            // Convert the buffer retrieved from the blockchain into the Model\r\n            let returnModel : T;\r\n            try {\r\n                returnModel = new this.TCreator(JSON.parse(buffer.toString()) as T);\r\n            } catch (err) {\r\n                logger.debug(`---CRUD-REPO : getWithStorageKey => Failed to convert the record from the retrieved buffer`);                   \r\n                logger.debug(`---CRUD-REPO : getWithStorageKey => ERROR: ${JSON.stringify(err)}`);\r\n            }\r\n\r\n            logger.debug(`---CRUD-REPO : getWithStorageKey => Retrieved the Model successfully`);  \r\n            return returnModel;\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    public async find(recordIDs: string[] = []) : Promise<T[]> { \r\n        let returnResult : T[] = [];\r\n        \r\n        // Attempt to retrieve the Model list from the blockchain \r\n        let iterator : Iterators.StateQueryIterator; \r\n        if (this.requirePDC) {\r\n            // Get the PDC name\r\n            const pdcName : string = await this.pdcResolver(this.TContext);\r\n\r\n            // Search for the data in the PDC with a matching partial storage key    \r\n            iterator = await this.TContext.stub.getPrivateDataByPartialCompositeKey(pdcName, this['objectType'], recordIDs);\r\n            if (iterator['iterator'] !== undefined) { iterator = iterator['iterator']; }\r\n        } else {\r\n            iterator = await this.TContext.stub.getStateByPartialCompositeKey(this['objectType'], recordIDs);\r\n        }\r\n\r\n        // Collect all the results from the iterator\r\n        while (true) {\r\n            const nextResult : Iterators.NextResult = await iterator.next();\r\n            if (nextResult.value) {\r\n                // If we did find something, then convert the value from the blockchain into a Model, otherwise return undefined\r\n                if (nextResult.value.value.length > 0) {\r\n                    // Convert the buffer retrieved from the blockchain into the Model\r\n                    const returnModel : T = new this.TCreator(JSON.parse(nextResult.value.value.toString('utf8')) as T);\r\n                    returnResult.push(returnModel);\r\n                }\r\n            }\r\n\r\n            // check to see if we have reached then end\r\n            if (nextResult.done) {\r\n                // explicitly close the iterator            \r\n                await iterator.close();\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return returnResult;\r\n    }\r\n\r\n    public async delete(recordID: string) : Promise<boolean> {\r\n        // Get the storage key for the Model\r\n        const storageKey : string = this.getStorageKey(recordID);\r\n\r\n        // Make sure the Model exists in the blockchain\r\n        const exists = await this.existsWithStorageKey(storageKey);\r\n        if (!exists) {\r\n            // The function succeeded, but we did not delete anything, so return false\r\n            return false;\r\n        } else {\r\n            if (this.requirePDC) {\r\n                // Get the PDC name\r\n                const pdcName : string = await this.pdcResolver(this.TContext);\r\n\r\n                // Delete the data in the PDC with the matching storageKey\r\n                await this.TContext.stub.deletePrivateData(pdcName, storageKey);\r\n            } else {\r\n                await this.TContext.stub.deleteState(storageKey);\r\n            }\r\n\r\n            // The function succeeded, and we deleted something, so return true\r\n            return true;\r\n        }\r\n    }\r\n\r\n    public async deleteMany(searchKey: string) : Promise<number> {\r\n        throw new Error('ERROR: deleteMany has not been implemented');\r\n    }\r\n\r\n    \r\n}"]}